package main

import (
	"context"
	"io"
	"log"
	"net/http"
	"os"
	"os/signal"
	"path"
	"rss-service/config"
	"rss-service/include"
	"rss-service/routers"
	"strings"
	"syscall"
	"time"

	"rss-service/middleware"

	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
	ginprometheus "github.com/zsais/go-gin-prometheus"

	_ "rss-service/docs" // docs is generated by Swag CLI, you have to import it.
)

var db *gorm.DB

// @title Watchlist Information System API
// @version 1.0
// @description Rest API document of Watchlist Information System
// @termsOfService COJ-App Team

// @host 10.1.2.124:9005
// @BasePath /api/v1
func main() {
	log.Print("Starting the service")

	port := os.Getenv("SERVER_PORT")
	if port == "" {
		config := config.InitConfig(os.Args)
		port = config.Server.Port
	}

	db = include.InitDB()
	defer db.Close()

	// write Log to file
	now := time.Now() //or time.Now().UTC()
	logFileName := "rss-service_" + now.Format("2006-01-02") + ".log"
	logFile, _ := os.OpenFile(path.Join("logs", logFileName), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0644)
	gin.DefaultWriter = io.MultiWriter(logFile)
	defer logFile.Close()

	app := gin.Default()

	// Prometheus
	p := ginprometheus.NewPrometheus("gin")

	p.ReqCntURLLabelMappingFn = func(c *gin.Context) string {
		url := c.Request.URL.Path
		for _, p := range c.Params {
			if p.Key == "id" {
				url = strings.Replace(url, p.Value, ":id", 1)
				break
			}
		}
		return url
	}

	p.Use(app)

	app.Use(middleware.CORS())

	routers.ApplyRoutes(app)

	srv := &http.Server{
		Addr:    ":" + port,
		Handler: app,
	}
	go func() {
		// service connections
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("listen: %s\n", err)
		}
	}()

	log.Print("The service is ready to listen and serve on PORT : " + port)

	// Wait for interrupt signal to gracefully shutdown the server with
	// a timeout of 5 seconds.
	quit := make(chan os.Signal, 1)
	// kill (no param) default send syscall.SIGTERM
	// kill -2 is syscall.SIGINT
	// kill -9 is syscall.SIGKILL but can't be catch, so don't need add it
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	log.Println("Shutdown Server ...")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	if err := srv.Shutdown(ctx); err != nil {
		log.Fatal("Server Shutdown: ", err)
	}

	log.Println("Server exiting")
}
